// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *EditVM) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditVM) encodeFields(e *jx.Encoder) {
	{
		if len(s.CpuMemConfig) != 0 {
			e.FieldStart("cpuMemConfig")
			e.Raw(s.CpuMemConfig)
		}
	}
	{
		if s.NetworkAdapters != nil {
			e.FieldStart("networkAdapters")
			e.ArrStart()
			for _, elem := range s.NetworkAdapters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VirtualDisks != nil {
			e.FieldStart("virtualDisks")
			e.ArrStart()
			for _, elem := range s.VirtualDisks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEditVM = [3]string{
	0: "cpuMemConfig",
	1: "networkAdapters",
	2: "virtualDisks",
}

// Decode decodes EditVM from json.
func (s *EditVM) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVM to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpuMemConfig":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.CpuMemConfig = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuMemConfig\"")
			}
		case "networkAdapters":
			if err := func() error {
				s.NetworkAdapters = make([]EditVMNetworkAdaptersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EditVMNetworkAdaptersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetworkAdapters = append(s.NetworkAdapters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkAdapters\"")
			}
		case "virtualDisks":
			if err := func() error {
				s.VirtualDisks = make([]EditVMVirtualDisksItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EditVMVirtualDisksItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VirtualDisks = append(s.VirtualDisks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"virtualDisks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditVM")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVM) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVM) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMBadRequest as json.
func (s *EditVMBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditVMBadRequest from json.
func (s *EditVMBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditVMBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMConflict as json.
func (s *EditVMConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditVMConflict from json.
func (s *EditVMConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditVMConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMForbidden as json.
func (s *EditVMForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditVMForbidden from json.
func (s *EditVMForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditVMForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMInternalServerError as json.
func (s *EditVMInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditVMInternalServerError from json.
func (s *EditVMInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditVMInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditVMNetworkAdaptersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditVMNetworkAdaptersItem) encodeFields(e *jx.Encoder) {
	{
		if s.ConnectAtPowerOn.Set {
			e.FieldStart("connectAtPowerOn")
			s.ConnectAtPowerOn.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NetworkDetails.Set {
			e.FieldStart("networkDetails")
			s.NetworkDetails.Encode(e)
		}
	}
	{
		if s.Operation.Set {
			e.FieldStart("operation")
			s.Operation.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditVMNetworkAdaptersItem = [5]string{
	0: "connectAtPowerOn",
	1: "name",
	2: "networkDetails",
	3: "operation",
	4: "type",
}

// Decode decodes EditVMNetworkAdaptersItem from json.
func (s *EditVMNetworkAdaptersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMNetworkAdaptersItem to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectAtPowerOn":
			if err := func() error {
				s.ConnectAtPowerOn.Reset()
				if err := s.ConnectAtPowerOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectAtPowerOn\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "networkDetails":
			if err := func() error {
				s.NetworkDetails.Reset()
				if err := s.NetworkDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkDetails\"")
			}
		case "operation":
			if err := func() error {
				s.Operation.Reset()
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditVMNetworkAdaptersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMNetworkAdaptersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMNetworkAdaptersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditVMNetworkAdaptersItemNetworkDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditVMNetworkAdaptersItemNetworkDetails) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditVMNetworkAdaptersItemNetworkDetails = [2]string{
	0: "name",
	1: "type",
}

// Decode decodes EditVMNetworkAdaptersItemNetworkDetails from json.
func (s *EditVMNetworkAdaptersItemNetworkDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMNetworkAdaptersItemNetworkDetails to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditVMNetworkAdaptersItemNetworkDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMNetworkAdaptersItemNetworkDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMNetworkAdaptersItemNetworkDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMNetworkAdaptersItemNetworkDetailsType as json.
func (s EditVMNetworkAdaptersItemNetworkDetailsType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditVMNetworkAdaptersItemNetworkDetailsType from json.
func (s *EditVMNetworkAdaptersItemNetworkDetailsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMNetworkAdaptersItemNetworkDetailsType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditVMNetworkAdaptersItemNetworkDetailsType(v) {
	case EditVMNetworkAdaptersItemNetworkDetailsTypeSTANDARDPORTGROUP:
		*s = EditVMNetworkAdaptersItemNetworkDetailsTypeSTANDARDPORTGROUP
	default:
		*s = EditVMNetworkAdaptersItemNetworkDetailsType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditVMNetworkAdaptersItemNetworkDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMNetworkAdaptersItemNetworkDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMNetworkAdaptersItemOperation as json.
func (s EditVMNetworkAdaptersItemOperation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditVMNetworkAdaptersItemOperation from json.
func (s *EditVMNetworkAdaptersItemOperation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMNetworkAdaptersItemOperation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditVMNetworkAdaptersItemOperation(v) {
	case EditVMNetworkAdaptersItemOperationADD:
		*s = EditVMNetworkAdaptersItemOperationADD
	case EditVMNetworkAdaptersItemOperationEDIT:
		*s = EditVMNetworkAdaptersItemOperationEDIT
	case EditVMNetworkAdaptersItemOperationDELETE:
		*s = EditVMNetworkAdaptersItemOperationDELETE
	default:
		*s = EditVMNetworkAdaptersItemOperation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditVMNetworkAdaptersItemOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMNetworkAdaptersItemOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMNetworkAdaptersItemType as json.
func (s EditVMNetworkAdaptersItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditVMNetworkAdaptersItemType from json.
func (s *EditVMNetworkAdaptersItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMNetworkAdaptersItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditVMNetworkAdaptersItemType(v) {
	case EditVMNetworkAdaptersItemTypeE1000:
		*s = EditVMNetworkAdaptersItemTypeE1000
	case EditVMNetworkAdaptersItemTypeE1000E:
		*s = EditVMNetworkAdaptersItemTypeE1000E
	case EditVMNetworkAdaptersItemTypePCNET32:
		*s = EditVMNetworkAdaptersItemTypePCNET32
	case EditVMNetworkAdaptersItemTypeVMXNET:
		*s = EditVMNetworkAdaptersItemTypeVMXNET
	case EditVMNetworkAdaptersItemTypeVMXNET2:
		*s = EditVMNetworkAdaptersItemTypeVMXNET2
	case EditVMNetworkAdaptersItemTypeVMXNET3:
		*s = EditVMNetworkAdaptersItemTypeVMXNET3
	default:
		*s = EditVMNetworkAdaptersItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditVMNetworkAdaptersItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMNetworkAdaptersItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMNotFound as json.
func (s *EditVMNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditVMNotFound from json.
func (s *EditVMNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditVMNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMServiceUnavailable as json.
func (s *EditVMServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditVMServiceUnavailable from json.
func (s *EditVMServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMServiceUnavailable to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditVMServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMUnauthorized as json.
func (s *EditVMUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes EditVMUnauthorized from json.
func (s *EditVMUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditVMUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditVMVirtualDisksItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditVMVirtualDisksItem) encodeFields(e *jx.Encoder) {
	{
		if s.DiskConfig.Set {
			e.FieldStart("diskConfig")
			s.DiskConfig.Encode(e)
		}
	}
	{
		if s.Operation.Set {
			e.FieldStart("operation")
			s.Operation.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditVMVirtualDisksItem = [2]string{
	0: "diskConfig",
	1: "operation",
}

// Decode decodes EditVMVirtualDisksItem from json.
func (s *EditVMVirtualDisksItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMVirtualDisksItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "diskConfig":
			if err := func() error {
				s.DiskConfig.Reset()
				if err := s.DiskConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"diskConfig\"")
			}
		case "operation":
			if err := func() error {
				s.Operation.Reset()
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditVMVirtualDisksItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMVirtualDisksItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMVirtualDisksItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditVMVirtualDisksItemDiskConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditVMVirtualDisksItemDiskConfig) encodeFields(e *jx.Encoder) {
	{
		if s.CapacityInMb.Set {
			e.FieldStart("capacityInMb")
			s.CapacityInMb.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.RetainFiles.Set {
			e.FieldStart("retainFiles")
			s.RetainFiles.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditVMVirtualDisksItemDiskConfig = [4]string{
	0: "capacityInMb",
	1: "id",
	2: "retainFiles",
	3: "type",
}

// Decode decodes EditVMVirtualDisksItemDiskConfig from json.
func (s *EditVMVirtualDisksItemDiskConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMVirtualDisksItemDiskConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capacityInMb":
			if err := func() error {
				s.CapacityInMb.Reset()
				if err := s.CapacityInMb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capacityInMb\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "retainFiles":
			if err := func() error {
				s.RetainFiles.Reset()
				if err := s.RetainFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retainFiles\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditVMVirtualDisksItemDiskConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVMVirtualDisksItemDiskConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMVirtualDisksItemDiskConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMVirtualDisksItemDiskConfigType as json.
func (s EditVMVirtualDisksItemDiskConfigType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditVMVirtualDisksItemDiskConfigType from json.
func (s *EditVMVirtualDisksItemDiskConfigType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMVirtualDisksItemDiskConfigType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditVMVirtualDisksItemDiskConfigType(v) {
	case EditVMVirtualDisksItemDiskConfigTypeIDE:
		*s = EditVMVirtualDisksItemDiskConfigTypeIDE
	case EditVMVirtualDisksItemDiskConfigTypeSCSI:
		*s = EditVMVirtualDisksItemDiskConfigTypeSCSI
	case EditVMVirtualDisksItemDiskConfigTypeSATA:
		*s = EditVMVirtualDisksItemDiskConfigTypeSATA
	case EditVMVirtualDisksItemDiskConfigTypeNVME:
		*s = EditVMVirtualDisksItemDiskConfigTypeNVME
	default:
		*s = EditVMVirtualDisksItemDiskConfigType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditVMVirtualDisksItemDiskConfigType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMVirtualDisksItemDiskConfigType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMVirtualDisksItemOperation as json.
func (s EditVMVirtualDisksItemOperation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditVMVirtualDisksItemOperation from json.
func (s *EditVMVirtualDisksItemOperation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVMVirtualDisksItemOperation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditVMVirtualDisksItemOperation(v) {
	case EditVMVirtualDisksItemOperationADD:
		*s = EditVMVirtualDisksItemOperationADD
	case EditVMVirtualDisksItemOperationEDIT:
		*s = EditVMVirtualDisksItemOperationEDIT
	case EditVMVirtualDisksItemOperationDELETE:
		*s = EditVMVirtualDisksItemOperationDELETE
	default:
		*s = EditVMVirtualDisksItemOperation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditVMVirtualDisksItemOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVMVirtualDisksItemOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EmptyResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EmptyResponse) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEmptyResponse = [0]string{}

// Decode decodes EmptyResponse from json.
func (s *EmptyResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmptyResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EmptyResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EmptyResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmptyResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("debugId")
		e.Str(s.DebugId)
	}
	{
		e.FieldStart("errorCode")
		e.Str(s.ErrorCode)
	}
	{
		e.FieldStart("httpStatusCode")
		e.Int(s.HttpStatusCode)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfErrorResponse = [4]string{
	0: "debugId",
	1: "errorCode",
	2: "httpStatusCode",
	3: "message",
}

// Decode decodes ErrorResponse from json.
func (s *ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "debugId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DebugId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debugId\"")
			}
		case "errorCode":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ErrorCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		case "httpStatusCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.HttpStatusCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpStatusCode\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorResponse) {
					name = jsonFieldsNameOfErrorResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualMachineRequestForbidden as json.
func (s *GetVirtualMachineRequestForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualMachineRequestForbidden from json.
func (s *GetVirtualMachineRequestForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualMachineRequestForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualMachineRequestForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualMachineRequestForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualMachineRequestForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualMachineRequestInternalServerError as json.
func (s *GetVirtualMachineRequestInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualMachineRequestInternalServerError from json.
func (s *GetVirtualMachineRequestInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualMachineRequestInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualMachineRequestInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualMachineRequestInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualMachineRequestInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualMachineRequestListForbidden as json.
func (s *GetVirtualMachineRequestListForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualMachineRequestListForbidden from json.
func (s *GetVirtualMachineRequestListForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualMachineRequestListForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualMachineRequestListForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualMachineRequestListForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualMachineRequestListForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualMachineRequestListInternalServerError as json.
func (s *GetVirtualMachineRequestListInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualMachineRequestListInternalServerError from json.
func (s *GetVirtualMachineRequestListInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualMachineRequestListInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualMachineRequestListInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualMachineRequestListInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualMachineRequestListInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualMachineRequestListNotFound as json.
func (s *GetVirtualMachineRequestListNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualMachineRequestListNotFound from json.
func (s *GetVirtualMachineRequestListNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualMachineRequestListNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualMachineRequestListNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualMachineRequestListNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualMachineRequestListNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualMachineRequestListUnauthorized as json.
func (s *GetVirtualMachineRequestListUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualMachineRequestListUnauthorized from json.
func (s *GetVirtualMachineRequestListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualMachineRequestListUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualMachineRequestListUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualMachineRequestListUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualMachineRequestListUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualMachineRequestNotFound as json.
func (s *GetVirtualMachineRequestNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualMachineRequestNotFound from json.
func (s *GetVirtualMachineRequestNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualMachineRequestNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualMachineRequestNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualMachineRequestNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualMachineRequestNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetVirtualMachineRequestUnauthorized as json.
func (s *GetVirtualMachineRequestUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetVirtualMachineRequestUnauthorized from json.
func (s *GetVirtualMachineRequestUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVirtualMachineRequestUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetVirtualMachineRequestUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVirtualMachineRequestUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVirtualMachineRequestUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVM) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVM) encodeFields(e *jx.Encoder) {
	{
		if s.Destination.Set {
			e.FieldStart("destination")
			s.Destination.Encode(e)
		}
	}
	{
		if s.ImageSource.Set {
			e.FieldStart("imageSource")
			s.ImageSource.Encode(e)
		}
	}
	{
		if s.NetworkConfig.Set {
			e.FieldStart("networkConfig")
			s.NetworkConfig.Encode(e)
		}
	}
	{
		e.FieldStart("storageConfig")
		s.StorageConfig.Encode(e)
	}
	{
		e.FieldStart("vmConfig")
		s.VmConfig.Encode(e)
	}
	{
		if s.VmPolicy != nil {
			e.FieldStart("vmPolicy")
			e.ArrStart()
			for _, elem := range s.VmPolicy {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHCIDeployVM = [6]string{
	0: "destination",
	1: "imageSource",
	2: "networkConfig",
	3: "storageConfig",
	4: "vmConfig",
	5: "vmPolicy",
}

// Decode decodes HCIDeployVM from json.
func (s *HCIDeployVM) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVM to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "destination":
			if err := func() error {
				s.Destination.Reset()
				if err := s.Destination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		case "imageSource":
			if err := func() error {
				s.ImageSource.Reset()
				if err := s.ImageSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageSource\"")
			}
		case "networkConfig":
			if err := func() error {
				s.NetworkConfig.Reset()
				if err := s.NetworkConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkConfig\"")
			}
		case "storageConfig":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.StorageConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageConfig\"")
			}
		case "vmConfig":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.VmConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmConfig\"")
			}
		case "vmPolicy":
			if err := func() error {
				s.VmPolicy = make([]HCIDeployVMVmPolicyItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HCIDeployVMVmPolicyItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VmPolicy = append(s.VmPolicy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmPolicy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVM")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHCIDeployVM) {
					name = jsonFieldsNameOfHCIDeployVM[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVM) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVM) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMBadRequest as json.
func (s *HCIDeployVMBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes HCIDeployVMBadRequest from json.
func (s *HCIDeployVMBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HCIDeployVMBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVMDestination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVMDestination) encodeFields(e *jx.Encoder) {
	{
		if s.ClusterId.Set {
			e.FieldStart("clusterId")
			s.ClusterId.Encode(e)
		}
	}
	{
		if s.FolderId.Set {
			e.FieldStart("folderId")
			s.FolderId.Encode(e)
		}
	}
	{
		if s.HostId.Set {
			e.FieldStart("hostId")
			s.HostId.Encode(e)
		}
	}
	{
		if s.ResourcePoolId.Set {
			e.FieldStart("resourcePoolId")
			s.ResourcePoolId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHCIDeployVMDestination = [4]string{
	0: "clusterId",
	1: "folderId",
	2: "hostId",
	3: "resourcePoolId",
}

// Decode decodes HCIDeployVMDestination from json.
func (s *HCIDeployVMDestination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMDestination to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterId":
			if err := func() error {
				s.ClusterId.Reset()
				if err := s.ClusterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterId\"")
			}
		case "folderId":
			if err := func() error {
				s.FolderId.Reset()
				if err := s.FolderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folderId\"")
			}
		case "hostId":
			if err := func() error {
				s.HostId.Reset()
				if err := s.HostId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostId\"")
			}
		case "resourcePoolId":
			if err := func() error {
				s.ResourcePoolId.Reset()
				if err := s.ResourcePoolId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourcePoolId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVMDestination")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMDestination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMDestination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMForbidden as json.
func (s *HCIDeployVMForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes HCIDeployVMForbidden from json.
func (s *HCIDeployVMForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HCIDeployVMForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVMImageSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVMImageSource) encodeFields(e *jx.Encoder) {
	{
		if s.ImageId.Set {
			e.FieldStart("imageId")
			s.ImageId.Encode(e)
		}
	}
	{
		if s.ImageName.Set {
			e.FieldStart("imageName")
			s.ImageName.Encode(e)
		}
	}
	{
		if s.ImageSourceType.Set {
			e.FieldStart("imageSourceType")
			s.ImageSourceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfHCIDeployVMImageSource = [3]string{
	0: "imageId",
	1: "imageName",
	2: "imageSourceType",
}

// Decode decodes HCIDeployVMImageSource from json.
func (s *HCIDeployVMImageSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMImageSource to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "imageId":
			if err := func() error {
				s.ImageId.Reset()
				if err := s.ImageId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageId\"")
			}
		case "imageName":
			if err := func() error {
				s.ImageName.Reset()
				if err := s.ImageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageName\"")
			}
		case "imageSourceType":
			if err := func() error {
				s.ImageSourceType.Reset()
				if err := s.ImageSourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageSourceType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVMImageSource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMImageSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMImageSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMImageSourceImageSourceType as json.
func (s HCIDeployVMImageSourceImageSourceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HCIDeployVMImageSourceImageSourceType from json.
func (s *HCIDeployVMImageSourceImageSourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMImageSourceImageSourceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HCIDeployVMImageSourceImageSourceType(v) {
	case HCIDeployVMImageSourceImageSourceTypeHYPERVISORIMAGELIBRARY:
		*s = HCIDeployVMImageSourceImageSourceTypeHYPERVISORIMAGELIBRARY
	default:
		*s = HCIDeployVMImageSourceImageSourceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HCIDeployVMImageSourceImageSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMImageSourceImageSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMInternalServerError as json.
func (s *HCIDeployVMInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes HCIDeployVMInternalServerError from json.
func (s *HCIDeployVMInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HCIDeployVMInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVMNetworkConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVMNetworkConfig) encodeFields(e *jx.Encoder) {
	{
		if s.IpAllocationPolicy.Set {
			e.FieldStart("ipAllocationPolicy")
			s.IpAllocationPolicy.Encode(e)
		}
	}
	{
		if s.NetworkMapping != nil {
			e.FieldStart("networkMapping")
			e.ArrStart()
			for _, elem := range s.NetworkMapping {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHCIDeployVMNetworkConfig = [2]string{
	0: "ipAllocationPolicy",
	1: "networkMapping",
}

// Decode decodes HCIDeployVMNetworkConfig from json.
func (s *HCIDeployVMNetworkConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMNetworkConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ipAllocationPolicy":
			if err := func() error {
				s.IpAllocationPolicy.Reset()
				if err := s.IpAllocationPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipAllocationPolicy\"")
			}
		case "networkMapping":
			if err := func() error {
				s.NetworkMapping = make([]HCIDeployVMNetworkConfigNetworkMappingItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HCIDeployVMNetworkConfigNetworkMappingItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NetworkMapping = append(s.NetworkMapping, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkMapping\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVMNetworkConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMNetworkConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMNetworkConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMNetworkConfigIpAllocationPolicy as json.
func (s HCIDeployVMNetworkConfigIpAllocationPolicy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HCIDeployVMNetworkConfigIpAllocationPolicy from json.
func (s *HCIDeployVMNetworkConfigIpAllocationPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMNetworkConfigIpAllocationPolicy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HCIDeployVMNetworkConfigIpAllocationPolicy(v) {
	case HCIDeployVMNetworkConfigIpAllocationPolicyDHCPPOLICY:
		*s = HCIDeployVMNetworkConfigIpAllocationPolicyDHCPPOLICY
	case HCIDeployVMNetworkConfigIpAllocationPolicyFIXEDPOLICY:
		*s = HCIDeployVMNetworkConfigIpAllocationPolicyFIXEDPOLICY
	default:
		*s = HCIDeployVMNetworkConfigIpAllocationPolicy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HCIDeployVMNetworkConfigIpAllocationPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMNetworkConfigIpAllocationPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVMNetworkConfigNetworkMappingItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVMNetworkConfigNetworkMappingItem) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Network.Set {
			e.FieldStart("network")
			s.Network.Encode(e)
		}
	}
}

var jsonFieldsNameOfHCIDeployVMNetworkConfigNetworkMappingItem = [2]string{
	0: "name",
	1: "network",
}

// Decode decodes HCIDeployVMNetworkConfigNetworkMappingItem from json.
func (s *HCIDeployVMNetworkConfigNetworkMappingItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMNetworkConfigNetworkMappingItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "network":
			if err := func() error {
				s.Network.Reset()
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVMNetworkConfigNetworkMappingItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMNetworkConfigNetworkMappingItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMNetworkConfigNetworkMappingItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVMStorageConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVMStorageConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("defaultDatastoreId")
		e.Str(s.DefaultDatastoreId)
	}
	{
		if s.ProvisioningType.Set {
			e.FieldStart("provisioningType")
			s.ProvisioningType.Encode(e)
		}
	}
}

var jsonFieldsNameOfHCIDeployVMStorageConfig = [2]string{
	0: "defaultDatastoreId",
	1: "provisioningType",
}

// Decode decodes HCIDeployVMStorageConfig from json.
func (s *HCIDeployVMStorageConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMStorageConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultDatastoreId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DefaultDatastoreId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultDatastoreId\"")
			}
		case "provisioningType":
			if err := func() error {
				s.ProvisioningType.Reset()
				if err := s.ProvisioningType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provisioningType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVMStorageConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHCIDeployVMStorageConfig) {
					name = jsonFieldsNameOfHCIDeployVMStorageConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMStorageConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMStorageConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMStorageConfigProvisioningType as json.
func (s HCIDeployVMStorageConfigProvisioningType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HCIDeployVMStorageConfigProvisioningType from json.
func (s *HCIDeployVMStorageConfigProvisioningType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMStorageConfigProvisioningType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HCIDeployVMStorageConfigProvisioningType(v) {
	case HCIDeployVMStorageConfigProvisioningTypeTHIN:
		*s = HCIDeployVMStorageConfigProvisioningTypeTHIN
	case HCIDeployVMStorageConfigProvisioningTypeTHICK:
		*s = HCIDeployVMStorageConfigProvisioningTypeTHICK
	default:
		*s = HCIDeployVMStorageConfigProvisioningType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HCIDeployVMStorageConfigProvisioningType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMStorageConfigProvisioningType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMUnauthorized as json.
func (s *HCIDeployVMUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes HCIDeployVMUnauthorized from json.
func (s *HCIDeployVMUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HCIDeployVMUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVMVmConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVMVmConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("acceptEula")
		e.Bool(s.AcceptEula)
	}
	{
		if s.Annotation.Set {
			e.FieldStart("annotation")
			s.Annotation.Encode(e)
		}
	}
	{
		if s.Locale.Set {
			e.FieldStart("locale")
			s.Locale.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.NumberOfVms.Set {
			e.FieldStart("numberOfVms")
			s.NumberOfVms.Encode(e)
		}
	}
	{
		if s.PowerOn.Set {
			e.FieldStart("powerOn")
			s.PowerOn.Encode(e)
		}
	}
	{
		if s.PropertyConfig != nil {
			e.FieldStart("propertyConfig")
			e.ArrStart()
			for _, elem := range s.PropertyConfig {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHCIDeployVMVmConfig = [7]string{
	0: "acceptEula",
	1: "annotation",
	2: "locale",
	3: "name",
	4: "numberOfVms",
	5: "powerOn",
	6: "propertyConfig",
}

// Decode decodes HCIDeployVMVmConfig from json.
func (s *HCIDeployVMVmConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMVmConfig to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "acceptEula":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AcceptEula = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acceptEula\"")
			}
		case "annotation":
			if err := func() error {
				s.Annotation.Reset()
				if err := s.Annotation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotation\"")
			}
		case "locale":
			if err := func() error {
				s.Locale.Reset()
				if err := s.Locale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "numberOfVms":
			if err := func() error {
				s.NumberOfVms.Reset()
				if err := s.NumberOfVms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfVms\"")
			}
		case "powerOn":
			if err := func() error {
				s.PowerOn.Reset()
				if err := s.PowerOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"powerOn\"")
			}
		case "propertyConfig":
			if err := func() error {
				s.PropertyConfig = make([]HCIDeployVMVmConfigPropertyConfigItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HCIDeployVMVmConfigPropertyConfigItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PropertyConfig = append(s.PropertyConfig, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"propertyConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVMVmConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHCIDeployVMVmConfig) {
					name = jsonFieldsNameOfHCIDeployVMVmConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMVmConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMVmConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVMVmConfigPropertyConfigItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVMVmConfigPropertyConfigItem) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfHCIDeployVMVmConfigPropertyConfigItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes HCIDeployVMVmConfigPropertyConfigItem from json.
func (s *HCIDeployVMVmConfigPropertyConfigItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMVmConfigPropertyConfigItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVMVmConfigPropertyConfigItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMVmConfigPropertyConfigItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMVmConfigPropertyConfigItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HCIDeployVMVmPolicyItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HCIDeployVMVmPolicyItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfHCIDeployVMVmPolicyItem = [2]string{
	0: "id",
	1: "type",
}

// Decode decodes HCIDeployVMVmPolicyItem from json.
func (s *HCIDeployVMVmPolicyItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMVmPolicyItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HCIDeployVMVmPolicyItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HCIDeployVMVmPolicyItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMVmPolicyItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMVmPolicyItemType as json.
func (s HCIDeployVMVmPolicyItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HCIDeployVMVmPolicyItemType from json.
func (s *HCIDeployVMVmPolicyItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HCIDeployVMVmPolicyItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HCIDeployVMVmPolicyItemType(v) {
	case HCIDeployVMVmPolicyItemTypeVMPROTECTIONPOLICY:
		*s = HCIDeployVMVmPolicyItemTypeVMPROTECTIONPOLICY
	case HCIDeployVMVmPolicyItemTypeVMPROVISIONINGPOLICY:
		*s = HCIDeployVMVmPolicyItemTypeVMPROVISIONINGPOLICY
	default:
		*s = HCIDeployVMVmPolicyItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HCIDeployVMVmPolicyItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HCIDeployVMVmPolicyItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMNetworkAdaptersItemNetworkDetails as json.
func (o OptEditVMNetworkAdaptersItemNetworkDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EditVMNetworkAdaptersItemNetworkDetails from json.
func (o *OptEditVMNetworkAdaptersItemNetworkDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditVMNetworkAdaptersItemNetworkDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditVMNetworkAdaptersItemNetworkDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditVMNetworkAdaptersItemNetworkDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMNetworkAdaptersItemNetworkDetailsType as json.
func (o OptEditVMNetworkAdaptersItemNetworkDetailsType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditVMNetworkAdaptersItemNetworkDetailsType from json.
func (o *OptEditVMNetworkAdaptersItemNetworkDetailsType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditVMNetworkAdaptersItemNetworkDetailsType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditVMNetworkAdaptersItemNetworkDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditVMNetworkAdaptersItemNetworkDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMNetworkAdaptersItemOperation as json.
func (o OptEditVMNetworkAdaptersItemOperation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditVMNetworkAdaptersItemOperation from json.
func (o *OptEditVMNetworkAdaptersItemOperation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditVMNetworkAdaptersItemOperation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditVMNetworkAdaptersItemOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditVMNetworkAdaptersItemOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMNetworkAdaptersItemType as json.
func (o OptEditVMNetworkAdaptersItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditVMNetworkAdaptersItemType from json.
func (o *OptEditVMNetworkAdaptersItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditVMNetworkAdaptersItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditVMNetworkAdaptersItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditVMNetworkAdaptersItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMVirtualDisksItemDiskConfig as json.
func (o OptEditVMVirtualDisksItemDiskConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EditVMVirtualDisksItemDiskConfig from json.
func (o *OptEditVMVirtualDisksItemDiskConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditVMVirtualDisksItemDiskConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditVMVirtualDisksItemDiskConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditVMVirtualDisksItemDiskConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMVirtualDisksItemDiskConfigType as json.
func (o OptEditVMVirtualDisksItemDiskConfigType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditVMVirtualDisksItemDiskConfigType from json.
func (o *OptEditVMVirtualDisksItemDiskConfigType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditVMVirtualDisksItemDiskConfigType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditVMVirtualDisksItemDiskConfigType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditVMVirtualDisksItemDiskConfigType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditVMVirtualDisksItemOperation as json.
func (o OptEditVMVirtualDisksItemOperation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditVMVirtualDisksItemOperation from json.
func (o *OptEditVMVirtualDisksItemOperation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditVMVirtualDisksItemOperation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditVMVirtualDisksItemOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditVMVirtualDisksItemOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMDestination as json.
func (o OptHCIDeployVMDestination) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HCIDeployVMDestination from json.
func (o *OptHCIDeployVMDestination) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHCIDeployVMDestination to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHCIDeployVMDestination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHCIDeployVMDestination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMImageSource as json.
func (o OptHCIDeployVMImageSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HCIDeployVMImageSource from json.
func (o *OptHCIDeployVMImageSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHCIDeployVMImageSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHCIDeployVMImageSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHCIDeployVMImageSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMImageSourceImageSourceType as json.
func (o OptHCIDeployVMImageSourceImageSourceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HCIDeployVMImageSourceImageSourceType from json.
func (o *OptHCIDeployVMImageSourceImageSourceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHCIDeployVMImageSourceImageSourceType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHCIDeployVMImageSourceImageSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHCIDeployVMImageSourceImageSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMNetworkConfig as json.
func (o OptHCIDeployVMNetworkConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HCIDeployVMNetworkConfig from json.
func (o *OptHCIDeployVMNetworkConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHCIDeployVMNetworkConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHCIDeployVMNetworkConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHCIDeployVMNetworkConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMNetworkConfigIpAllocationPolicy as json.
func (o OptHCIDeployVMNetworkConfigIpAllocationPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HCIDeployVMNetworkConfigIpAllocationPolicy from json.
func (o *OptHCIDeployVMNetworkConfigIpAllocationPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHCIDeployVMNetworkConfigIpAllocationPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHCIDeployVMNetworkConfigIpAllocationPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHCIDeployVMNetworkConfigIpAllocationPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMStorageConfigProvisioningType as json.
func (o OptHCIDeployVMStorageConfigProvisioningType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HCIDeployVMStorageConfigProvisioningType from json.
func (o *OptHCIDeployVMStorageConfigProvisioningType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHCIDeployVMStorageConfigProvisioningType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHCIDeployVMStorageConfigProvisioningType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHCIDeployVMStorageConfigProvisioningType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HCIDeployVMVmPolicyItemType as json.
func (o OptHCIDeployVMVmPolicyItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HCIDeployVMVmPolicyItemType from json.
func (o *OptHCIDeployVMVmPolicyItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHCIDeployVMVmPolicyItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHCIDeployVMVmPolicyItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHCIDeployVMVmPolicyItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRequestsListItems as json.
func (o OptVMRequestsListItems) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VMRequestsListItems from json.
func (o *OptVMRequestsListItems) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVMRequestsListItems to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVMRequestsListItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVMRequestsListItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMDeleteBadRequest as json.
func (s *VMDeleteBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMDeleteBadRequest from json.
func (s *VMDeleteBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMDeleteBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMDeleteBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMDeleteBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMDeleteBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMDeleteConflict as json.
func (s *VMDeleteConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMDeleteConflict from json.
func (s *VMDeleteConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMDeleteConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMDeleteConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMDeleteConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMDeleteConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMDeleteForbidden as json.
func (s *VMDeleteForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMDeleteForbidden from json.
func (s *VMDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMDeleteForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMDeleteForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMDeleteForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMDeleteForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMDeleteInternalServerError as json.
func (s *VMDeleteInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMDeleteInternalServerError from json.
func (s *VMDeleteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMDeleteInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMDeleteInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMDeleteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMDeleteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMDeleteNotFound as json.
func (s *VMDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMDeleteNotFound from json.
func (s *VMDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMDeleteNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMDeleteServiceUnavailable as json.
func (s *VMDeleteServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMDeleteServiceUnavailable from json.
func (s *VMDeleteServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMDeleteServiceUnavailable to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMDeleteServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMDeleteServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMDeleteServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMDeleteUnauthorized as json.
func (s *VMDeleteUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMDeleteUnauthorized from json.
func (s *VMDeleteUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMDeleteUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMDeleteUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMDeleteUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMDeleteUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VMDeployInstance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VMDeployInstance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("requestId")
		e.Str(s.RequestId)
	}
	{
		if s.VmId.Set {
			e.FieldStart("vmId")
			s.VmId.Encode(e)
		}
	}
	{
		e.FieldStart("vmName")
		e.Str(s.VmName)
	}
	{
		e.FieldStart("vmStatus")
		e.Str(s.VmStatus)
	}
	{
		if s.VmStateMessage.Set {
			e.FieldStart("vmStateMessage")
			s.VmStateMessage.Encode(e)
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completedAt")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfVMDeployInstance = [6]string{
	0: "requestId",
	1: "vmId",
	2: "vmName",
	3: "vmStatus",
	4: "vmStateMessage",
	5: "completedAt",
}

// Decode decodes VMDeployInstance from json.
func (s *VMDeployInstance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMDeployInstance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requestId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RequestId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		case "vmId":
			if err := func() error {
				s.VmId.Reset()
				if err := s.VmId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmId\"")
			}
		case "vmName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VmName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmName\"")
			}
		case "vmStatus":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VmStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmStatus\"")
			}
		case "vmStateMessage":
			if err := func() error {
				s.VmStateMessage.Reset()
				if err := s.VmStateMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vmStateMessage\"")
			}
		case "completedAt":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VMDeployInstance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVMDeployInstance) {
					name = jsonFieldsNameOfVMDeployInstance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMDeployInstance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMDeployInstance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOffBadRequest as json.
func (s *VMPowerOffBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOffBadRequest from json.
func (s *VMPowerOffBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOffBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOffBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOffBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOffBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOffConflict as json.
func (s *VMPowerOffConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOffConflict from json.
func (s *VMPowerOffConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOffConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOffConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOffConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOffConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOffForbidden as json.
func (s *VMPowerOffForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOffForbidden from json.
func (s *VMPowerOffForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOffForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOffForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOffForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOffForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOffInternalServerError as json.
func (s *VMPowerOffInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOffInternalServerError from json.
func (s *VMPowerOffInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOffInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOffInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOffInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOffInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOffNotFound as json.
func (s *VMPowerOffNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOffNotFound from json.
func (s *VMPowerOffNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOffNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOffNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOffNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOffNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOffServiceUnavailable as json.
func (s *VMPowerOffServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOffServiceUnavailable from json.
func (s *VMPowerOffServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOffServiceUnavailable to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOffServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOffServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOffServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOffUnauthorized as json.
func (s *VMPowerOffUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOffUnauthorized from json.
func (s *VMPowerOffUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOffUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOffUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOffUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOffUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOnBadRequest as json.
func (s *VMPowerOnBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOnBadRequest from json.
func (s *VMPowerOnBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOnBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOnBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOnBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOnBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOnConflict as json.
func (s *VMPowerOnConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOnConflict from json.
func (s *VMPowerOnConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOnConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOnConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOnConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOnConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOnForbidden as json.
func (s *VMPowerOnForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOnForbidden from json.
func (s *VMPowerOnForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOnForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOnForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOnForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOnForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOnInternalServerError as json.
func (s *VMPowerOnInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOnInternalServerError from json.
func (s *VMPowerOnInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOnInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOnInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOnInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOnInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOnNotFound as json.
func (s *VMPowerOnNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOnNotFound from json.
func (s *VMPowerOnNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOnNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOnNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOnNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOnNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOnServiceUnavailable as json.
func (s *VMPowerOnServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOnServiceUnavailable from json.
func (s *VMPowerOnServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOnServiceUnavailable to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOnServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOnServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOnServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerOnUnauthorized as json.
func (s *VMPowerOnUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerOnUnauthorized from json.
func (s *VMPowerOnUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerOnUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerOnUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerOnUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerOnUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerResetBadRequest as json.
func (s *VMPowerResetBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerResetBadRequest from json.
func (s *VMPowerResetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerResetBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerResetBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerResetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerResetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerResetConflict as json.
func (s *VMPowerResetConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerResetConflict from json.
func (s *VMPowerResetConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerResetConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerResetConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerResetConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerResetConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerResetForbidden as json.
func (s *VMPowerResetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerResetForbidden from json.
func (s *VMPowerResetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerResetForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerResetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerResetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerResetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerResetInternalServerError as json.
func (s *VMPowerResetInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerResetInternalServerError from json.
func (s *VMPowerResetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerResetInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerResetInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerResetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerResetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerResetNotFound as json.
func (s *VMPowerResetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerResetNotFound from json.
func (s *VMPowerResetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerResetNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerResetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerResetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerResetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerResetServiceUnavailable as json.
func (s *VMPowerResetServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerResetServiceUnavailable from json.
func (s *VMPowerResetServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerResetServiceUnavailable to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerResetServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerResetServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerResetServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMPowerResetUnauthorized as json.
func (s *VMPowerResetUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMPowerResetUnauthorized from json.
func (s *VMPowerResetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMPowerResetUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMPowerResetUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMPowerResetUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMPowerResetUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRefreshConflict as json.
func (s *VMRefreshConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRefreshConflict from json.
func (s *VMRefreshConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRefreshConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRefreshConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRefreshConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRefreshConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRefreshForbidden as json.
func (s *VMRefreshForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRefreshForbidden from json.
func (s *VMRefreshForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRefreshForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRefreshForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRefreshForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRefreshForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRefreshInternalServerError as json.
func (s *VMRefreshInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRefreshInternalServerError from json.
func (s *VMRefreshInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRefreshInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRefreshInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRefreshInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRefreshInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRefreshNotFound as json.
func (s *VMRefreshNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRefreshNotFound from json.
func (s *VMRefreshNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRefreshNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRefreshNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRefreshNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRefreshNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRefreshUnauthorized as json.
func (s *VMRefreshUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRefreshUnauthorized from json.
func (s *VMRefreshUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRefreshUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRefreshUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRefreshUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRefreshUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VMRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VMRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("requestId")
		e.Str(s.RequestId)
	}
	{
		e.FieldStart("operation")
		s.Operation.Encode(e)
	}
	{
		e.FieldStart("requestStatus")
		s.RequestStatus.Encode(e)
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
	{
		if s.DatacenterId.Set {
			e.FieldStart("datacenterId")
			s.DatacenterId.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completedAt")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("requestMetadata")
		e.Str(s.RequestMetadata)
	}
}

var jsonFieldsNameOfVMRequest = [8]string{
	0: "requestId",
	1: "operation",
	2: "requestStatus",
	3: "workspaceId",
	4: "datacenterId",
	5: "createdAt",
	6: "completedAt",
	7: "requestMetadata",
}

// Decode decodes VMRequest from json.
func (s *VMRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requestId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RequestId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		case "operation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "requestStatus":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RequestStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestStatus\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		case "datacenterId":
			if err := func() error {
				s.DatacenterId.Reset()
				if err := s.DatacenterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datacenterId\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "completedAt":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedAt\"")
			}
		case "requestMetadata":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.RequestMetadata = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VMRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10100111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVMRequest) {
					name = jsonFieldsNameOfVMRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRequestOperation as json.
func (s VMRequestOperation) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VMRequestOperation from json.
func (s *VMRequestOperation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRequestOperation to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VMRequestOperation(v) {
	case VMRequestOperationVmDeploy:
		*s = VMRequestOperationVmDeploy
	case VMRequestOperationVmReconfigure:
		*s = VMRequestOperationVmReconfigure
	case VMRequestOperationVmPowerOn:
		*s = VMRequestOperationVmPowerOn
	case VMRequestOperationVmPowerOff:
		*s = VMRequestOperationVmPowerOff
	case VMRequestOperationVmReset:
		*s = VMRequestOperationVmReset
	case VMRequestOperationVmRestart:
		*s = VMRequestOperationVmRestart
	case VMRequestOperationVmShutdown:
		*s = VMRequestOperationVmShutdown
	case VMRequestOperationVmDelete:
		*s = VMRequestOperationVmDelete
	default:
		*s = VMRequestOperation(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VMRequestOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRequestOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRequestRequestStatus as json.
func (s VMRequestRequestStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VMRequestRequestStatus from json.
func (s *VMRequestRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRequestRequestStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VMRequestRequestStatus(v) {
	case VMRequestRequestStatusNew:
		*s = VMRequestRequestStatusNew
	case VMRequestRequestStatusInprogress:
		*s = VMRequestRequestStatusInprogress
	case VMRequestRequestStatusSuccess:
		*s = VMRequestRequestStatusSuccess
	case VMRequestRequestStatusFailure:
		*s = VMRequestRequestStatusFailure
	default:
		*s = VMRequestRequestStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VMRequestRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRequestRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VMRequestWithDeploy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VMRequestWithDeploy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vm_request")
		s.VMRequest.Encode(e)
	}
	{
		e.FieldStart("vm_deploy_list")
		e.ArrStart()
		for _, elem := range s.VMDeployList {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVMRequestWithDeploy = [2]string{
	0: "vm_request",
	1: "vm_deploy_list",
}

// Decode decodes VMRequestWithDeploy from json.
func (s *VMRequestWithDeploy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRequestWithDeploy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vm_request":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.VMRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vm_request\"")
			}
		case "vm_deploy_list":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.VMDeployList = make([]VMDeployInstance, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VMDeployInstance
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VMDeployList = append(s.VMDeployList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vm_deploy_list\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VMRequestWithDeploy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVMRequestWithDeploy) {
					name = jsonFieldsNameOfVMRequestWithDeploy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRequestWithDeploy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRequestWithDeploy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VMRequestsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VMRequestsList) encodeFields(e *jx.Encoder) {
	{
		if s.VMMinusRequestsListCount.Set {
			e.FieldStart("vm-requests_list_count")
			s.VMMinusRequestsListCount.Encode(e)
		}
	}
	{
		if s.VMMinusDeployListCount.Set {
			e.FieldStart("vm-deploy_list_count")
			s.VMMinusDeployListCount.Encode(e)
		}
	}
	{
		if s.Items.Set {
			e.FieldStart("items")
			s.Items.Encode(e)
		}
	}
}

var jsonFieldsNameOfVMRequestsList = [3]string{
	0: "vm-requests_list_count",
	1: "vm-deploy_list_count",
	2: "items",
}

// Decode decodes VMRequestsList from json.
func (s *VMRequestsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRequestsList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vm-requests_list_count":
			if err := func() error {
				s.VMMinusRequestsListCount.Reset()
				if err := s.VMMinusRequestsListCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vm-requests_list_count\"")
			}
		case "vm-deploy_list_count":
			if err := func() error {
				s.VMMinusDeployListCount.Reset()
				if err := s.VMMinusDeployListCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vm-deploy_list_count\"")
			}
		case "items":
			if err := func() error {
				s.Items.Reset()
				if err := s.Items.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VMRequestsList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRequestsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRequestsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VMRequestsListItems) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VMRequestsListItems) encodeFields(e *jx.Encoder) {
	{
		if s.VMRequetsList != nil {
			e.FieldStart("vm_requets_list")
			e.ArrStart()
			for _, elem := range s.VMRequetsList {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VMDeployList != nil {
			e.FieldStart("vm_deploy_list")
			e.ArrStart()
			for _, elem := range s.VMDeployList {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVMRequestsListItems = [2]string{
	0: "vm_requets_list",
	1: "vm_deploy_list",
}

// Decode decodes VMRequestsListItems from json.
func (s *VMRequestsListItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRequestsListItems to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vm_requets_list":
			if err := func() error {
				s.VMRequetsList = make([]VMRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VMRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VMRequetsList = append(s.VMRequetsList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vm_requets_list\"")
			}
		case "vm_deploy_list":
			if err := func() error {
				s.VMDeployList = make([]VMDeployInstance, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VMDeployInstance
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VMDeployList = append(s.VMDeployList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vm_deploy_list\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VMRequestsListItems")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRequestsListItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRequestsListItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRestartGuestOSBadRequest as json.
func (s *VMRestartGuestOSBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRestartGuestOSBadRequest from json.
func (s *VMRestartGuestOSBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRestartGuestOSBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRestartGuestOSBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRestartGuestOSBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRestartGuestOSBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRestartGuestOSConflict as json.
func (s *VMRestartGuestOSConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRestartGuestOSConflict from json.
func (s *VMRestartGuestOSConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRestartGuestOSConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRestartGuestOSConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRestartGuestOSConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRestartGuestOSConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRestartGuestOSForbidden as json.
func (s *VMRestartGuestOSForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRestartGuestOSForbidden from json.
func (s *VMRestartGuestOSForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRestartGuestOSForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRestartGuestOSForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRestartGuestOSForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRestartGuestOSForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRestartGuestOSInternalServerError as json.
func (s *VMRestartGuestOSInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRestartGuestOSInternalServerError from json.
func (s *VMRestartGuestOSInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRestartGuestOSInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRestartGuestOSInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRestartGuestOSInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRestartGuestOSInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRestartGuestOSNotFound as json.
func (s *VMRestartGuestOSNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRestartGuestOSNotFound from json.
func (s *VMRestartGuestOSNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRestartGuestOSNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRestartGuestOSNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRestartGuestOSNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRestartGuestOSNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRestartGuestOSServiceUnavailable as json.
func (s *VMRestartGuestOSServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRestartGuestOSServiceUnavailable from json.
func (s *VMRestartGuestOSServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRestartGuestOSServiceUnavailable to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRestartGuestOSServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRestartGuestOSServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRestartGuestOSServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMRestartGuestOSUnauthorized as json.
func (s *VMRestartGuestOSUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMRestartGuestOSUnauthorized from json.
func (s *VMRestartGuestOSUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMRestartGuestOSUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMRestartGuestOSUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMRestartGuestOSUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMRestartGuestOSUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMShutdownGuestOSBadRequest as json.
func (s *VMShutdownGuestOSBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMShutdownGuestOSBadRequest from json.
func (s *VMShutdownGuestOSBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMShutdownGuestOSBadRequest to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMShutdownGuestOSBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMShutdownGuestOSBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMShutdownGuestOSBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMShutdownGuestOSConflict as json.
func (s *VMShutdownGuestOSConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMShutdownGuestOSConflict from json.
func (s *VMShutdownGuestOSConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMShutdownGuestOSConflict to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMShutdownGuestOSConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMShutdownGuestOSConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMShutdownGuestOSConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMShutdownGuestOSForbidden as json.
func (s *VMShutdownGuestOSForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMShutdownGuestOSForbidden from json.
func (s *VMShutdownGuestOSForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMShutdownGuestOSForbidden to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMShutdownGuestOSForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMShutdownGuestOSForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMShutdownGuestOSForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMShutdownGuestOSInternalServerError as json.
func (s *VMShutdownGuestOSInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMShutdownGuestOSInternalServerError from json.
func (s *VMShutdownGuestOSInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMShutdownGuestOSInternalServerError to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMShutdownGuestOSInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMShutdownGuestOSInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMShutdownGuestOSInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMShutdownGuestOSNotFound as json.
func (s *VMShutdownGuestOSNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMShutdownGuestOSNotFound from json.
func (s *VMShutdownGuestOSNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMShutdownGuestOSNotFound to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMShutdownGuestOSNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMShutdownGuestOSNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMShutdownGuestOSNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMShutdownGuestOSServiceUnavailable as json.
func (s *VMShutdownGuestOSServiceUnavailable) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMShutdownGuestOSServiceUnavailable from json.
func (s *VMShutdownGuestOSServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMShutdownGuestOSServiceUnavailable to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMShutdownGuestOSServiceUnavailable(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMShutdownGuestOSServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMShutdownGuestOSServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VMShutdownGuestOSUnauthorized as json.
func (s *VMShutdownGuestOSUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorResponse)(s)

	unwrapped.Encode(e)
}

// Decode decodes VMShutdownGuestOSUnauthorized from json.
func (s *VMShutdownGuestOSUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VMShutdownGuestOSUnauthorized to nil")
	}
	var unwrapped ErrorResponse
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = VMShutdownGuestOSUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VMShutdownGuestOSUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VMShutdownGuestOSUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
